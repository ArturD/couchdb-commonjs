(function (exports) {
  if (typeof JSON === "undefined") {
    throw new Error("JSON is required.  Plesae include json2.js if you are running this in the browser");
  }

  var 
    EventEmitter   = require("./events").EventEmitter,
    Q              = require("./promise"),
    HttpClient     = require("promised-io/http-client").Client,
    Trait          = require("traits").Trait,
    base64         = require("base64"),
    when           = Q.when,
    defineProperty = Object.defineProperty,
    httpMethod     = {
      POST:   "POST",
      GET:    "GET",
      DELETE: "DELETE",
      PUT:    "PUT"
    };

  exports.createClient = function(opts) {
    opts = opts || {};

    var 
      client = new HttpClient(),
      couchClient = Trait.create(new CouchClient(client), Trait(opts));
    
    return couchClient;
  };
  
  function CouchClient(httpClient){
    this.httpClient = httpClient;
  }
    
  /**
   * @api private
   */
  CouchClient.prototype._queueRequest = function(opts, cb) {
    if (this.user && this.pass) {
      opts.headers.authorization = "Basic " + encodeURIComponent(user + ":" + pass);
    }
    
    if (opts.query) {
      opts.path += encodeOptions(opts.query);
    }
    
    opts.headers["Content-Type"] = opts.headers["Content-Type"] || "application/json";
    
    var
      responseText, url, req = this.req;
    
    url = this.host;
    if (!url.match(/^http:\/\//)) {
      url = "http://" + url;
    }
    
    if (this.port) {
      url += ":" + this.port;
    }
    
    url += opts.path;
    
    function nextRequest() {
      console.log("opts: " + JSON.stringify(opts));
      console.log(url);
      req.open(opts.method.toUpperCase(), url, true);
      
      req.onreadystatechange = function() {
        var resonseJSON;
        
        if (req.readyState === 4) {
          
          try {
	    console.log("readyState is 4", req.responseText);
            responseJSON = JSON.parse(req.responseText);
          } catch(err) {
            cb(err);
            req.emit("end", err);
            return;
          }
            
          if (responseJSON.error) {
            cb(responseJSON);
          } else {
            cb(null, responseJSON);
          }  
            
          req.emit("end");
        }
        
      };
      
      for (var k in opts.headers) {
        if (Object.hasOwnProperty(k)) {
          req.setRequestHeader(k, headers[k]);
        }
      }
      
      if (this.user) {
        req.setRequestHeader("Authorization", "Basic " + Base64.encode(this.user + ":" + this.password));
      }
      
      if (opts.data) {
        opts.data = toJSON(opts.data);
      }
      req.send(opts.data || null);
    }
    
    if (req.readyState === 0) {
      nextRequest();
    } else {
      req._requestQueue.push(nextRequest);
    }
  };
  
  CouchClient.prototype.request = function(opts) {
    var defaults = {
      hostname: this.host,
      port: this.port,
      headers: { "Content-Type": "application/json" }
    };
    
    opts = complete(opts, defaults);
    if (this.user) {
      opts.headers["Authorization"] = "Basic "+base64.encode(this.user+":"+this.password);
    }
    
    return when(this.httpClient.request(opts), function success(resp) { 
      var body = "";
      return when(resp.body.forEach(function(chunk) { body += chunk; }), function() { return JSON.parse(body); });
    });
  };
  
  CouchClient.prototype.allDbs = function() {
    return this.request({
      pathInfo: "/_all_dbs"
    });
  };
  
  CouchClient.prototype.config = function(cb) {
    return this.request({
      pathInfo: "/_config"
    });
  };
  
  /**
   * Retrieve unique identifiers generated by CouchDB
   *
   * @param {Number|Function} count   If this is a function, it becomes the callback.  If it is a number, it is the number of unique identifiers to retrieve
   * @param {Function} cb Callback
   * @api public
   */
  CouchClient.prototype.uuids = function(count, cb) {
    var jsgiRequest = {
      pathInfo: "/_uuids"
    };
    
    if (count) {
      jsgiRequest.queryString = "count="+count;
    }

    return this.request(jsgiRequest);
  };
  
  CouchClient.prototype.replicate = function(source, target, opts) {
    opts = complete({}, {
      source: source,
      target: target
    }, opts);
    
    return this.request({
      method: httpMethod.POST,
      pathInfo: "/_replicate",
      body: [JSON.stringify(opts)]
    });
  };
  
  CouchClient.prototype.stats = function() {
    var args = Array.prototype.slice.call(arguments);
      
    return this.request({
      pathInfo: "/_stats" + ((args && args.length > 0) ? "/" + args.join("/") : "")
    });
  };
  
  CouchClient.prototype.activeTasks = function(cb) {
    return this.request({
      path: "/_active_tasks"
    }, cb);
  };
  
  CouchClient.prototype.db = function(name) {
    if (name === undefined || name === null || name === "") {
      throw new Error("Name must contain a value");
    }
    
    var
      couchClient = this;
      db          = Object.create(new Database(), 
                                    { 
                                      "name": {
                                        get: function() { return name; }
                                      },
                                      "client": {
                                        get: function() { return couchClient; }
                                      }
                                    });
    
    db.request = function(opts) {
      opts = opts || {};
      opts.pathInfo = "/"+name+(opts.path || "");
      
      return couchClient.request(opts);
    };
    
    return db;
  };
  
  var Database = exports.Database = function() {};
  
  Database.prototype.exists = function(cb) {
    return when(this.request({ pathInfo: "" }),
      function(resp) {
        return !(resp.error && resp.error === "not_found");
      }
    );
  };
  
  Database.prototype.info = function() {
    return this.request({}, cb);
  };
  
  Database.prototype.create = function() {
    return this.request({
      method: httpMethod.PUT
    });
  };
  
  /**
   * Permanently delete database
   *
   * @return {Promise} a promise
   * @api public
   */
  Database.prototype.remove = function(cb) {
    return this.request({
      method: httpMethod.DELETE
    }, cb);
  };
  
  Database.prototype.allDocs = function() {
    return this.request({
      pathInfo: "/_all_docs"
    });
  };
  
  /**
   * Retrieve document by unique identifier
   *
   * @param {String}   id  Unique identifier of the document
   * @param {Function} cb  Callback
   * @api public
   */
  Database.prototype.getDoc = Database.prototype.openDoc = function(id, cb) {
    return this.request({
      path: "/"+id
    }, cb);
  };
  
  Database.prototype.saveDoc = function(doc, opts) {
    var 
      method = httpMethod.PUT
    , path = "/";
    
    if (doc._id === undefined) {
      method = httpMethod.POST;
    } else {
      path += doc._id;
    }
    
    return this.request({
      method: method,
      path: path,
      body: typeof doc === "string" ? [doc] : [JSON.stringify(doc)]
    });
  };
  
  Database.prototype.removeDoc = function(id, rev, cb) {
    return this.request({
      method: httpMethod.DELETE,
      path: "/"+id,
      query: {rev:rev}
    }, cb);
  };
  
  /**
   * @api private
   */
  function getRequestOptions(args) {
    args = Array.prototype.slice.call(args);
    
    var 
      cb     = args.pop(),
      method = args.shift(),
      path   = args.shift(),
      data   = args.shift(),
      opts;
    
  
    if (typeof method === "object") {
      opts = method;
    } else if (typeof method === "string" && typeof path !== "string") {
      opts = {
        path: method,
        query: path
      };
    } else {
      opts = {
        method: method,
        path: path,
        data: data
      };
    }
    
    opts.cb = cb;
    
    return opts;
  }
  
  function removeAttr(attr) {
    var val = this[attr];
    delete this[attr];
    
    return val;
  }
  
  /**
   * Stringify function embedded inside of objects. Useful for couch views.
   * @api private
   */
  function toJSON(data) {
    return JSON.stringify(data, function(key, val) {
      if (typeof val == 'function') {
        return val.toString();
      }
      return val;
    });
  }
    
  // Convert a options object to an url query string.
  // ex: {key:'value',key2:'value2'} becomes '?key="value"&key2="value2"'
  function encodeOptions(options) {
    var buf = [];
    if (typeof(options) == "object" && options !== null) {
      for (var name in options) {
        if (options.hasOwnProperty(name)) { 
          var value = options[name];
          if (name == "key" || name == "startkey" || name == "endkey") {
            value = toJSON(value);
          }
          buf.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
        }
      }
    }
    if (!buf.length) {
      return "";
    }
    return "?" + buf.join("&");
  }
  
  /**
   * Updates an object with the properties of another object(s) if those
   * properties are not already defined for the target object. First argument is
   * the object to complete, the remaining arguments are considered sources to
   * complete from. If multiple sources contain the same property, the value of
   * the first source with that property will be the one inserted in to the
   * target.
   *
   * example usage:
   * util.complete({}, { hello: "world" });  // -> { hello: "world" }
   * util.complete({ hello: "narwhal" }, { hello: "world" }); // -> { hello: "narwhal" }
   * util.complete({}, { hello: "world" }, { hello: "le monde" }); // -> { hello: "world" }
   *
   * @returns Completed object
   * @type Object
   * @api private
   */
  function complete() {
      return variadicHelper(arguments, function(target, source) {
          var key;
          for (key in source) {
              if (
                  Object.prototype.hasOwnProperty.call(source, key) &&
                  !Object.prototype.hasOwnProperty.call(target, key)
              ) {
                  target[key] = source[key];
              }
          }
      });
  }
  
  /**
   * @param args Arguments list of the calling function
   * First argument should be a callback that takes target and source parameters.
   * Second argument should be target.
   * Remaining arguments are treated a sources.
   *
   * @returns Target
   * @type Object
   * @api private
   */
  function variadicHelper(args, callback) {
      var sources = Array.prototype.slice.call(args);
      var target = sources.shift();
  
      sources.forEach(function(source) {
          callback(target, source);
      });
  
      return target;
  }
  


})(
  (function() {
    if (typeof exports !== "undefined") {
      return exports;
    } else if (typeof window !== "undefined") {
      window.COUCH = {};
      return window.COUCH;
    }
    
    throw new Error("Could not load module");
  }()));
