(function (exports) {
  if (typeof JSON === "undefined") {
    throw new Error("JSON is required.  Plesae include json2.js if you are running this in the browser for IE support");
  }
  
  var 
    defineProperty = Object.defineProperty,
    httpMethod     = {
      POST:   "POST",
      GET:    "GET",
      DELETE: "DELETE",
      PUT:    "PUT"
    };

  exports.createClient = function(xhrConstructor, port, host, user, pass) {
    if (typeof xhrConstructor !== "function") { 
      pass = user;
      user = host;
      host = port;
      port = xhrConstructor;
      if (typeof XMLHttpRequest !== "undefined") {
        xhrConstructor = XMLHttpRequest;
      } else {
        xhrConstructor = require("./node/XMLHttpRequest").XMLHttpRequest;
      }
    }
    
    var 
      req = new xhrConstructor(),
      reqEventEmitter = new EventEmitter();
    
    ["emit","addListener","removeAllListeners","removeListener"].forEach(function(x) { 
      req[x] = function() { reqEventEmitter[x].apply(reqEventEmitter, arguments); };
    });
    
    req._requestQueue = [];
    req.addListener("end", function() {
      req.abort();
      if (req._requestQueue.length > 0) {
        var nextRequest = req._requestQueue.shift();
        nextRequest();
      }
    });
      
    if (isNaN(port)) {
      host = port;
      user = host;
      pass = user;
    }
    
    host = host || "localhost";
    port = port || 5984;
    
    var couchClient = Trait.create(new CouchClient(), Trait({ 
      port: port,
      host: host,
      user: user,
      password: pass,
      req: req
    }));
    
    return couchClient;
  };
  
  function CouchClient(){}
    
  /**
   * @api private
   */
  CouchClient.prototype._queueRequest = function(opts, cb) {
    if (this.user && this.pass) {
      opts.headers.authorization = "Basic " + encodeURIComponent(user + ":" + pass);
    }
    
    if (opts.query) {
      opts.path += encodeOptions(opts.query);
    }
    
    opts.headers["Content-Type"] = opts.headers["Content-Type"] || "application/json";
    
    var
      responseText, url, req = this.req;
    
    url = this.host;
    if (!url.match(/^http:\/\//)) {
      url = "http://" + url;
    }
    
    if (this.port) {
      url += ":" + this.port;
    }
    
    url += opts.path;
    
    function nextRequest() {
      req.open(opts.method.toUpperCase(), url, true);
      
      req.onreadystatechange = function() {
        var resonseJSON;
        
        if (req.readyState === 4) {
          
          try {
            responseJSON = JSON.parse(req.responseText);
          } catch(err) {
            cb(err);
            req.emit("end", err);
            return;
          }
            
          if (responseJSON.error) {
            cb(responseJSON);
          } else {
            cb(null, responseJSON);
          }  
            
          req.emit("end");
        }
        
      };
      
      for (var k in opts.headers) {
        if (Object.hasOwnProperty(k)) {
          req.setRequestHeader(k, headers[k]);
        }
      }
      
      if (this.user) {
        req.setRequestHeader("Authorization", "Basic " + Base64.encode(this.user + ":" + this.password));
      }
      
      if (opts.data) {
        opts.data = toJSON(opts.data);
      }
      req.send(opts.data || null);
    }
    
    if (req.readyState === 0) {
      nextRequest();
    } else {
      req._requestQueue.push(nextRequest);
    }
  };
  
  CouchClient.prototype.request = function(method, path, data, cb) {
    var 
      defaults = {
        method:  httpMethod.GET,
        path:    "/",
        headers: {},
        data:    null,
        query:   null
      }, 
      opts = complete(getRequestOptions(arguments), defaults);
    
    return this._queueRequest(opts, removeAttr.call(opts, "cb"));
  };
  
  CouchClient.prototype.allDbs = function(cb) {
    return this.request({
      path: "/_all_dbs"
    }, cb);
  };
  
  CouchClient.prototype.config = function(cb) {
    return this.request({
      path: "/_config"
    }, cb);
  };
  
  /**
   * Retrieve unique identifiers generated by CouchDB
   *
   * @param {Number|Function} count   If this is a function, it becomes the callback.  If it is a number, it is the number of unique identifiers to retrieve
   * @param {Function} cb Callback
   * @api public
   */
  CouchClient.prototype.uuids = function(count, cb) {
    if (!cb && typeof(count) === "function") {
      cb = count;
      count = null;
    }
    
    return this.request({
      path: "/_uuids" + (count ? "?count="+count : "")
    }, cb);
  };
  
  CouchClient.prototype.replicate = function(source, target, opts, cb) {
    if (!cb && typeof(opts) === "function") {
      cb   = opts;
      opts = {};
    }
    
    opts = complete({
      source: source,
      target: target
    }, opts);
    
    return this.request({
      method: httpMethod.POST,
      path: "/_replicate",
      data: opts
    }, cb);
  };
  
  CouchClient.prototype.stats = function() {
    var
      args = Array.prototype.slice.call(arguments),
      cb   = args.pop();
    
    if (typeof cb !== "function") {
      throw new TypeError("last argument to 'stats' should be a callback function");
    }
    
    return this.request({
      path: "/_stats" + ((args && args.length > 0) ? "/"+args.join("/") : "")
    }, cb);
  };
  
  CouchClient.prototype.activeTasks = function(cb) {
    return this.request({
      path: "/_active_tasks"
    }, cb);
  };
  
  CouchClient.prototype.db = function(name) {
    if (name === undefined || name === null || name === "") {
      throw new Error("Name must contain a value");
    }
    
    var
      couchClient = this;
      db          = Object.create(new Database(), 
                                    { 
                                      "name": {
                                        get: function() { return name; }
                                      },
                                      "client": {
                                        get: function() { return couchClient; }
                                      }
                                    });
    
    db.request = function(method, path, data, cb) {
      var opts = getRequestOptions(arguments);
      opts.path = "/"+name+(opts.path || "");
      
      return couchClient.request(opts, removeAttr.call(opts, "cb"));
    };
    
    return db;
  };
  
  var Database = exports.Database = function() {};
  
  Database.prototype.exists = function(cb) {
    this.request({ path: "" }, function(err) {
      cb(null, !(err && err.error && err.error === "not_found"));
    });
  };
  
  Database.prototype.info = function(cb) {
    return this.request({}, cb);
  };
  
  Database.prototype.create = function(cb) {
    return this.request({
      method: httpMethod.PUT
    }, cb);
  };
  
  /**
   * Permanently delete database
   *
   * @param {Function} cb
   * @api public
   */
  Database.prototype.remove = function(cb) {
    return this.request({
      method: httpMethod.DELETE
    }, cb);
  };
  
  /**
   * Retrieve document by unique identifier
   *
   * @param {String}   id  Unique identifier of the document
   * @param {Function} cb  Callback
   * @api public
   */
  Database.prototype.getDoc = Database.prototype.openDoc = function(id, cb) {
    return this.request({
      path: "/"+id
    }, cb);
  };
  
  Database.prototype.saveDoc = function(id, doc, cb) {
    if (typeof id === "object") {
      cb = doc;
      return this.request({
        method: httpMethod.POST,
        data: id
      }, cb);
    }
    
    return this.request({
      method: httpMethod.PUT,
      path: "/"+id,
      data: doc
    }, cb);
  };
  
  Database.prototype.removeDoc = function(id, rev, cb) {
    return this.request({
      method: httpMethod.DELETE,
      path: "/"+id,
      query: {rev:rev}
    }, cb);
  };
  
  /**
   * @api private
   */
  function getRequestOptions(args) {
    args = Array.prototype.slice.call(args);
    
    var 
      cb     = args.pop(),
      method = args.shift(),
      path   = args.shift(),
      data   = args.shift(),
      opts;
    
  
    if (typeof method === "object") {
      opts = method;
    } else if (typeof method === "string" && typeof path !== "string") {
      opts = {
        path: method,
        query: path
      };
    } else {
      opts = {
        method: method,
        path: path,
        data: data
      };
    }
    
    opts.cb = cb;
    
    return opts;
  }
  
  function removeAttr(attr) {
    var val = this[attr];
    delete this[attr];
    
    return val;
  }
  
  /**
   * Stringify function embedded inside of objects. Useful for couch views.
   * @api private
   */
  function toJSON(data) {
    return JSON.stringify(data, function(key, val) {
      if (typeof val == 'function') {
        return val.toString();
      }
      return val;
    });
  }
    
  // Convert a options object to an url query string.
  // ex: {key:'value',key2:'value2'} becomes '?key="value"&key2="value2"'
  function encodeOptions(options) {
    var buf = [];
    if (typeof(options) == "object" && options !== null) {
      for (var name in options) {
        if (options.hasOwnProperty(name)) { 
          var value = options[name];
          if (name == "key" || name == "startkey" || name == "endkey") {
            value = toJSON(value);
          }
          buf.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
        }
      }
    }
    if (!buf.length) {
      return "";
    }
    return "?" + buf.join("&");
  }
  
  /**
   * Updates an object with the properties of another object(s) if those
   * properties are not already defined for the target object. First argument is
   * the object to complete, the remaining arguments are considered sources to
   * complete from. If multiple sources contain the same property, the value of
   * the first source with that property will be the one inserted in to the
   * target.
   *
   * example usage:
   * util.complete({}, { hello: "world" });  // -> { hello: "world" }
   * util.complete({ hello: "narwhal" }, { hello: "world" }); // -> { hello: "narwhal" }
   * util.complete({}, { hello: "world" }, { hello: "le monde" }); // -> { hello: "world" }
   *
   * @returns Completed object
   * @type Object
   * @api private
   */
  function complete() {
      return variadicHelper(arguments, function(target, source) {
          var key;
          for (key in source) {
              if (
                  Object.prototype.hasOwnProperty.call(source, key) &&
                  !Object.prototype.hasOwnProperty.call(target, key)
              ) {
                  target[key] = source[key];
              }
          }
      });
  }
  
  /**
   * @param args Arguments list of the calling function
   * First argument should be a callback that takes target and source parameters.
   * Second argument should be target.
   * Remaining arguments are treated a sources.
   *
   * @returns Target
   * @type Object
   * @api private
   */
  function variadicHelper(args, callback) {
      var sources = Array.prototype.slice.call(args);
      var target = sources.shift();
  
      sources.forEach(function(source) {
          callback(target, source);
      });
  
      return target;
  }
  
  
// -- kriskowal Kris Kowal Copyright (C) 2009-2010 MIT License
// -- tlrobinson Tom Robinson
// dantman Daniel Friesen

/*!
    Copyright (c) 2009, 280 North Inc. http://280north.com/
    MIT License. http://github.com/280north/narwhal/blob/master/README.md
*/

  // Brings an environment as close to ECMAScript 5 compliance
  // as is possible with the facilities of erstwhile engines.
  
  // ES5 Draft
  // http://www.ecma-international.org/publications/files/drafts/tc39-2009-050.pdf
  
  // NOTE: this is a draft, and as such, the URL is subject to change.  If the
  // link is broken, check in the parent directory for the latest TC39 PDF.
  // http://www.ecma-international.org/publications/files/drafts/
  
  // Previous ES5 Draft
  // http://www.ecma-international.org/publications/files/drafts/tc39-2009-025.pdf
  // This is a broken link to the previous draft of ES5 on which most of the
  // numbered specification references and quotes herein were taken.  Updating
  // these references and quotes to reflect the new document would be a welcome
  // volunteer project.
  
  //
  // Array
  // =====
  //
  
  // ES5 15.4.3.2 
  if (!Array.isArray) {
    Array.isArray = function(obj) {
      return Object.prototype.toString.call(obj) == "[object Array]";
    };
  }
  
  // ES5 15.4.4.18
  if (!Array.prototype.forEach) {
    Array.prototype.forEach =  function(block, thisObject) {
      var len = this.length >>> 0;
      for (var i = 0; i < len; i++) {
        if (i in this) {
          block.call(thisObject, this[i], i, this);
        }
      }
    };
  }
  
  // ES5 15.4.4.19
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
  if (!Array.prototype.map) {
    Array.prototype.map = function(fun /*, thisp*/) {
      var len = this.length >>> 0;
      if (typeof fun != "function") {
        throw new TypeError();
      }
  
      var res = new Array(len);
      var thisp = arguments[1];
      for (var i = 0; i < len; i++) {
        if (i in this) {
          res[i] = fun.call(thisp, this[i], i, this);
        }
      }
  
      return res;
    };
  }
  
  // ES5 15.4.4.20
  if (!Array.prototype.filter) {
    Array.prototype.filter = function (block /*, thisp */) {
      var values = [];
      var thisp = arguments[1];
      for (var i = 0; i < this.length; i++) {
        if (block.call(thisp, this[i])) {
          values.push(this[i]);
        }
      }
      return values;
    };
  }
  
  // ES5 15.4.4.16
  if (!Array.prototype.every) {
    Array.prototype.every = function (block /*, thisp */) {
      var thisp = arguments[1];
      for (var i = 0; i < this.length; i++) {
        if (!block.call(thisp, this[i])) {
          return false;
        }
      }
      return true;
    };
  }
  
  // ES5 15.4.4.17
  if (!Array.prototype.some) {
    Array.prototype.some = function (block /*, thisp */) {
      var thisp = arguments[1];
      for (var i = 0; i < this.length; i++) {
        if (block.call(thisp, this[i])) {
          return true;
        }
      }
      return false;
    };
  }
  
  // ES5 15.4.4.21
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
  if (!Array.prototype.reduce) {
    Array.prototype.reduce = function(fun /*, initial*/) {
      var len = this.length >>> 0;
      if (typeof fun != "function") {
        throw new TypeError();
      }
  
      // no value to return if no initial value and an empty array
      if (len === 0 && arguments.length === 1) {
        throw new TypeError();
      }
  
      var i = 0, rv;
      if (arguments.length >= 2) {
        rv = arguments[1];
      } else {
        do {
          if (i in this) {
            rv = this[i++];
            break;
          }
  
          // if array contains no values, no initial value to return
          if (++i >= len) {
            throw new TypeError();
          }
        } while (true);
      }
  
      for (; i < len; i++) {
        if (i in this) {
          rv = fun.call(null, rv, this[i], i, this);
        }
      }
  
      return rv;
    };
  }
  
  // ES5 15.4.4.22
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
  if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function(fun /*, initial*/) {
      var len = this.length >>> 0;
      if (typeof fun != "function") {
        throw new TypeError();
      }
  
      // no value to return if no initial value, empty array
      if (len === 0 && arguments.length === 1) {
        throw new TypeError();
      }
  
      var i = len - 1, rv;
      if (arguments.length >= 2) {
        rv = arguments[1];
      } else {
        do {
          if (i in this) {
            rv = this[i--];
            break;
          }
  
          // if array contains no values, no initial value to return
          if (--i < 0) {
            throw new TypeError();
          }
        } while (true);
      }
  
      for (; i >= 0; i--) {
        if (i in this) {
          rv = fun.call(null, rv, this[i], i, this);
        }
      }
  
      return rv;
    };
  }
  
  // ES5 15.4.4.14
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (value /*, fromIndex */ ) {
      var length = this.length;
      if (!length) {
        return -1;
      }
      var i = arguments[1] || 0;
      if (i >= length) {
        return -1;
      }
      if (i < 0) {
        i += length;
      }
      for (; i < length; i++) {
        if (!Object.prototype.hasOwnProperty.call(this, i)) {
          continue;
        }
        if (value === this[i]) {
          return i;
        }
      }
      return -1;
    };
  }
  
  // ES5 15.4.4.15
  if (!Array.prototype.lastIndexOf) {
    Array.prototype.lastIndexOf = function (value /*, fromIndex */) {
      var length = this.length;
      if (!length) {
        return -1;
      }
      var i = arguments[1] || length;
      if (i < 0) {
        i += length;
      }
      i = Math.min(i, length - 1);
      for (; i >= 0; i--) {
        if (!Object.prototype.hasOwnProperty.call(this, i)) {
          continue;
        }
        if (value === this[i]) {
          return i;
        }
      }
      return -1;
    };
  }
  
    // Copyright (C) 2010 Google Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  // http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  
  // See http://code.google.com/p/es-lab/wiki/Traits
  // for background on traits and a description of this library
  
  var Trait = (function(){
  
    // == Ancillary functions ==
    
    var SUPPORTS_DEFINEPROP = (function() {
      if ("_supportsDefineProperty" in this) { return this._supportsDefineProperty; }
      try {
        var test = {};
        Object.defineProperty(test, 'x', {get: function() { return 0; } } );
        return (test.x === 0);
      } catch(e) {
        return false;
      }
    })();
    
    // IE8 implements Object.defineProperty and Object.getOwnPropertyDescriptor
    // only for DOM objects. These methods don't work on plain objects.
    // Hence, we need a more elaborate feature-test to see whether the browser truly
    // supports these methods:
    function supportsGOPD() {
      try {
        if (Object.getOwnPropertyDescriptor) {
          var test = {x:0};
          return !!Object.getOwnPropertyDescriptor(test,'x');        
        }
      } catch(e) {}
      return false;
    };
    function supportsDP() {
      try {
        if (Object.defineProperty) {
          var test = {};
          Object.defineProperty(test,'x',{value:0});
          return test.x === 0;
        }
      } catch(e) {}
      return false;
    };
  
    var call = Function.prototype.call;
  
    /**
     * An ad hoc version of bind that only binds the 'this' parameter.
     */
    var bindThis = Function.prototype.bind
      ? function(fun, self) { return Function.prototype.bind.call(fun, self); }
      : function(fun, self) {
          function funcBound(var_args) {
            return fun.apply(self, arguments);
          }
          return funcBound;
        };
  
    var hasOwnProperty = bindThis(call, Object.prototype.hasOwnProperty);
    var slice = bindThis(call, Array.prototype.slice);
      
    // feature testing such that traits.js runs on both ES3 and ES5
    var forEach = Array.prototype.forEach
        ? bindThis(call, Array.prototype.forEach)
        : function(arr, fun) {
            for (var i = 0, len = arr.length; i < len; i++) { fun(arr[i]); }
          };
        
    var freeze = Object.freeze || function(obj) { return obj; };
    var getPrototypeOf = Object.getPrototypeOf || function(obj) { return Object.prototype };
    var getOwnPropertyNames = Object.getOwnPropertyNames ||
        function(obj) {
          var props = [];
          for (var p in obj) { if (hasOwnProperty(obj,p)) { props.push(p); } }
          return props;
        };
    var getOwnPropertyDescriptor = supportsGOPD() ? Object.getOwnPropertyDescriptor :
        function(obj, name) {
          return {
            value: obj[name],
            enumerable: true,
            writable: true,
            configurable: true
          };
        };
    var defineProperty = supportsDP() ? Object.defineProperty :
        function(obj, name, pd) {
          obj[name] = pd.value;
        };
    var defineProperties = Object.defineProperties ||
        function(obj, propMap) {
          for (var name in propMap) {
            if (hasOwnProperty(propMap, name)) {
              defineProperty(obj, name, propMap[name]);
            }
          }
        };
    var Object_create = Object.create ||
        function(proto, propMap) {
          var self;
          function dummy() {};
          dummy.prototype = proto || Object.prototype;
          self = new dummy();
          if (propMap) {
            defineProperties(self, propMap);          
          }
          return self;
        };
    var getOwnProperties = Object.getOwnProperties ||
        function(obj) {
          var map = {};
          forEach(getOwnPropertyNames(obj), function (name) {
            map[name] = getOwnPropertyDescriptor(obj, name);
          });
          return map;
        };
    
    // end of ES3 - ES5 compatibility functions
    
    function makeConflictAccessor(name) {
      var accessor = function(var_args) {
        throw new Error("Conflicting property: "+name);
      };
      freeze(accessor.prototype);
      return freeze(accessor);
    };
  
    function makeRequiredPropDesc(name) {
      return freeze({
        value: undefined,
        enumerable: false,
        required: true
      });
    }
    
    function makeConflictingPropDesc(name) {
      var conflict = makeConflictAccessor(name);
      if (SUPPORTS_DEFINEPROP) {
        return freeze({
         get: conflict,
         set: conflict,
         enumerable: false,
         conflict: true
        }); 
      } else {
        return freeze({
          value: conflict,
          enumerable: false,
          conflict: true
        });
      }
    }
    
    /**
     * Are x and y not observably distinguishable?
     */
    function identical(x, y) {
      if (x === y) {
        // 0 === -0, but they are not identical
        return x !== 0 || 1/x === 1/y;
      } else {
        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        return x !== x && y !== y;
      }
    }
  
    // Note: isSameDesc should return true if both
    // desc1 and desc2 represent a 'required' property
    // (otherwise two composed required properties would be turned into a conflict)
    function isSameDesc(desc1, desc2) {
      // for conflicting properties, don't compare values because
      // the conflicting property values are never equal
      if (desc1.conflict && desc2.conflict) {
        return true;
      } else {
        return (   desc1.get === desc2.get
                && desc1.set === desc2.set
                && identical(desc1.value, desc2.value)
                && desc1.enumerable === desc2.enumerable
                && desc1.required === desc2.required
                && desc1.conflict === desc2.conflict); 
      }
    }
    
    function freezeAndBind(meth, self) {
      return freeze(bindThis(meth, self));
    }
  
    /* makeSet(['foo', ...]) => { foo: true, ...}
     *
     * makeSet returns an object whose own properties represent a set.
     *
     * Each string in the names array is added to the set.
     *
     * To test whether an element is in the set, perform:
     *   hasOwnProperty(set, element)
     */
    function makeSet(names) {
      var set = {};
      forEach(names, function (name) {
        set[name] = true;
      });
      return freeze(set);
    }
  
    // == singleton object to be used as the placeholder for a required property ==
    
    var required = freeze({ toString: function() { return '<Trait.required>'; } });
  
    // == The public API methods ==
  
    /**
     * var newTrait = trait({ foo:required, ... })
     *
     * @param object an object record (in principle an object literal)
     * @returns a new trait describing all of the own properties of the object
     *          (both enumerable and non-enumerable)
     *
     * As a general rule, 'trait' should be invoked with an
     * object literal, since the object merely serves as a record
     * descriptor. Both its identity and its prototype chain are irrelevant.
     * 
     * Data properties bound to function objects in the argument will be flagged
     * as 'method' properties. The prototype of these function objects is frozen.
     * 
     * Data properties bound to the 'required' singleton exported by this module
     * will be marked as 'required' properties.
     *
     * The <tt>trait</tt> function is pure if no other code can witness the
     * side-effects of freezing the prototypes of the methods. If <tt>trait</tt>
     * is invoked with an object literal whose methods are represented as
     * in-place anonymous functions, this should normally be the case.
     */
    function trait(obj) {
      var map = {};
      forEach(getOwnPropertyNames(obj), function (name) {
        var pd = getOwnPropertyDescriptor(obj, name);
        if (pd.value === required) {
          pd = makeRequiredPropDesc(name);
        } else if (typeof pd.value === 'function') {
          pd.method = true;
          if ('prototype' in pd.value) {
            freeze(pd.value.prototype);
          }
        } else {
          if (pd.get && pd.get.prototype) { freeze(pd.get.prototype); }
          if (pd.set && pd.set.prototype) { freeze(pd.set.prototype); }
        }
        map[name] = pd;
      });
      return map;
    }
  
    /**
     * var newTrait = compose(trait_1, trait_2, ..., trait_N)
     *
     * @param trait_i a trait object
     * @returns a new trait containing the combined own properties of
     *          all the trait_i.
     * 
     * If two or more traits have own properties with the same name, the new
     * trait will contain a 'conflict' property for that name. 'compose' is
     * a commutative and associative operation, and the order of its
     * arguments is not significant.
     *
     * If 'compose' is invoked with < 2 arguments, then:
     *   compose(trait_1) returns a trait equivalent to trait_1
     *   compose() returns an empty trait
     */
    function compose(var_args) {
      var traits = slice(arguments, 0);
      var newTrait = {};
      
      forEach(traits, function (trait) {
        forEach(getOwnPropertyNames(trait), function (name) {
          var pd = trait[name];
          if (hasOwnProperty(newTrait, name) &&
              !newTrait[name].required) {
            
            // a non-required property with the same name was previously defined
            // this is not a conflict if pd represents a 'required' property itself:
            if (pd.required) {
              return; // skip this property, the required property is now present
            }
              
            if (!isSameDesc(newTrait[name], pd)) {
              // a distinct, non-required property with the same name
              // was previously defined by another trait => mark as conflicting property
              newTrait[name] = makeConflictingPropDesc(name); 
            } // else,
            // properties are not in conflict if they refer to the same value
            
          } else {
            newTrait[name] = pd;
          }
        });
      });
      
      return freeze(newTrait);
    }
  
    /* var newTrait = exclude(['name', ...], trait)
     *
     * @param names a list of strings denoting property names.
     * @param trait a trait some properties of which should be excluded.
     * @returns a new trait with the same own properties as the original trait,
     *          except that all property names appearing in the first argument
     *          are replaced by required property descriptors.
     *
     * Note: exclude(A, exclude(B,t)) is equivalent to exclude(A U B, t)
     */
    function exclude(names, trait) {
      var exclusions = makeSet(names);
      var newTrait = {};
      
      forEach(getOwnPropertyNames(trait), function (name) {
        // required properties are not excluded but ignored
        if (!hasOwnProperty(exclusions, name) || trait[name].required) {
          newTrait[name] = trait[name];
        } else {
          // excluded properties are replaced by required properties
          newTrait[name] = makeRequiredPropDesc(name);
        }
      });
      
      return freeze(newTrait);
    }
  
    /**
     * var newTrait = override(trait_1, trait_2, ..., trait_N)
     *
     * @returns a new trait with all of the combined properties of the argument traits.
     *          In contrast to 'compose', 'override' immediately resolves all conflicts
     *          resulting from this composition by overriding the properties of later
     *          traits. Trait priority is from left to right. I.e. the properties of the
     *          leftmost trait are never overridden.
     *
     *  override is associative:
     *    override(t1,t2,t3) is equivalent to override(t1, override(t2, t3)) or
     *    to override(override(t1, t2), t3)
     *  override is not commutative: override(t1,t2) is not equivalent to override(t2,t1)
     *
     * override() returns an empty trait
     * override(trait_1) returns a trait equivalent to trait_1
     */
    function override(var_args) {
      var traits = slice(arguments, 0);
      var newTrait = {};
      forEach(traits, function (trait) {
        forEach(getOwnPropertyNames(trait), function (name) {
          var pd = trait[name];
          // add this trait's property to the composite trait only if
          // - the trait does not yet have this property
          // - or, the trait does have the property, but it's a required property
          if (!hasOwnProperty(newTrait, name) || newTrait[name].required) {
            newTrait[name] = pd;
          }
        });
      });
      return freeze(newTrait);
    }
    
    /**
     * var newTrait = override(dominantTrait, recessiveTrait)
     *
     * @returns a new trait with all of the properties of dominantTrait
     *          and all of the properties of recessiveTrait not in dominantTrait
     *
     * Note: override is associative:
     *   override(t1, override(t2, t3)) is equivalent to override(override(t1, t2), t3)
     */
    /*function override(frontT, backT) {
      var newTrait = {};
      // first copy all of backT's properties into newTrait
      forEach(getOwnPropertyNames(backT), function (name) {
        newTrait[name] = backT[name];
      });
      // now override all these properties with frontT's properties
      forEach(getOwnPropertyNames(frontT), function (name) {
        var pd = frontT[name];
        // frontT's required property does not override the provided property
        if (!(pd.required && hasOwnProperty(newTrait, name))) {
          newTrait[name] = pd; 
        }      
      });
      
      return freeze(newTrait);
    }*/
  
    /**
     * var newTrait = rename(map, trait)
     *
     * @param map an object whose own properties serve as a mapping from
              old names to new names.
     * @param trait a trait object
     * @returns a new trait with the same properties as the original trait,
     *          except that all properties whose name is an own property
     *          of map will be renamed to map[name], and a 'required' property
     *          for name will be added instead.
     *
     * rename({a: 'b'}, t) eqv compose(exclude(['a'],t),
     *                                 { a: { required: true },
     *                                   b: t[a] })
     *
     * For each renamed property, a required property is generated.
     * If the map renames two properties to the same name, a conflict is generated.
     * If the map renames a property to an existing unrenamed property, a conflict is generated.
     *
     * Note: rename(A, rename(B, t)) is equivalent to rename(\n -> A(B(n)), t)
     * Note: rename({...},exclude([...], t)) is not eqv to exclude([...],rename({...}, t))
     */
    function rename(map, trait) {
      var renamedTrait = {};
      forEach(getOwnPropertyNames(trait), function (name) {
        // required props are never renamed
        if (hasOwnProperty(map, name) && !trait[name].required) {
          var alias = map[name]; // alias defined in map
          if (hasOwnProperty(renamedTrait, alias) && !renamedTrait[alias].required) {
            // could happen if 2 props are mapped to the same alias
            renamedTrait[alias] = makeConflictingPropDesc(alias);
          } else {
            // add the property under an alias
            renamedTrait[alias] = trait[name];
          }
          // add a required property under the original name
          // but only if a property under the original name does not exist
          // such a prop could exist if an earlier prop in the trait was previously
          // aliased to this name
          if (!hasOwnProperty(renamedTrait, name)) {
            renamedTrait[name] = makeRequiredPropDesc(name);     
          }
        } else { // no alias defined
          if (hasOwnProperty(renamedTrait, name)) {
            // could happen if another prop was previously aliased to name
            if (!trait[name].required) {
              renamedTrait[name] = makeConflictingPropDesc(name);            
            }
            // else required property overridden by a previously aliased property
            // and otherwise ignored
          } else {
            renamedTrait[name] = trait[name];
          }
        }
      });
      
      return freeze(renamedTrait);
    }
    
    /**
     * var newTrait = resolve({ oldName: 'newName', excludeName: undefined, ... }, trait)
     *
     * This is a convenience function combining renaming and exclusion. It can be implemented
     * as <tt>rename(map, exclude(exclusions, trait))</tt> where map is the subset of
     * mappings from oldName to newName and exclusions is an array of all the keys that map
     * to undefined (or another falsy value).
     *
     * @param resolutions an object whose own properties serve as a mapping from
              old names to new names, or to undefined if the property should be excluded
     * @param trait a trait object
     * @returns a resolved trait with the same own properties as the original trait.
     *
     * In a resolved trait, all own properties whose name is an own property
     * of resolutions will be renamed to resolutions[name] if it is truthy,
     * or their value is changed into a required property descriptor if
     * resolutions[name] is falsy.
     *
     * Note, it's important to _first_ exclude, _then_ rename, since exclude
     * and rename are not associative, for example:
     * rename({a: 'b'}, exclude(['b'], trait({ a:1,b:2 }))) eqv trait({b:1})
     * exclude(['b'], rename({a: 'b'}, trait({ a:1,b:2 }))) eqv trait({b:Trait.required})
     *
     * writing resolve({a:'b', b: undefined},trait({a:1,b:2})) makes it clear that
     * what is meant is to simply drop the old 'b' and rename 'a' to 'b'
     */
    function resolve(resolutions, trait) {
      var renames = {};
      var exclusions = [];
      // preprocess renamed and excluded properties
      for (var name in resolutions) {
        if (hasOwnProperty(resolutions, name)) {
          if (resolutions[name]) { // old name -> new name
            renames[name] = resolutions[name];
          } else { // name -> undefined
            exclusions.push(name);
          }
        }
      }
      return rename(renames, exclude(exclusions, trait));
    }
  
    /**
     * var obj = create(proto, trait)
     *
     * @param proto denotes the prototype of the completed object
     * @param trait a trait object to be turned into a complete object
     * @returns an object with all of the properties described by the trait.
     * @throws 'Missing required property' the trait still contains a required property.
     * @throws 'Remaining conflicting property' if the trait still contains a conflicting property.
     *
     * Trait.create is like Object.create, except that it generates
     * high-integrity or final objects. In addition to creating a new object
     * from a trait, it also ensures that:
     *    - an exception is thrown if 'trait' still contains required properties
     *    - an exception is thrown if 'trait' still contains conflicting properties
     *    - the object is and all of its accessor and method properties are frozen
     *    - the 'this' pseudovariable in all accessors and methods of the object is
     *      bound to the composed object.
     *
     *  Use Object.create instead of Trait.create if you want to create
     *  abstract or malleable objects. Keep in mind that for such objects:
     *    - no exception is thrown if 'trait' still contains required properties
     *      (the properties are simply dropped from the composite object)
     *    - no exception is thrown if 'trait' still contains conflicting properties
     *      (these properties remain as conflicting properties in the composite object)
     *    - neither the object nor its accessor and method properties are frozen
     *    - the 'this' pseudovariable in all accessors and methods of the object is
     *      left unbound.
     */
    function create(proto, trait) {
      var self = Object_create(proto);
      var properties = {};
    
      forEach(getOwnPropertyNames(trait), function (name) {
        var pd = trait[name];
        // check for remaining 'required' properties
        // Note: it's OK for the prototype to provide the properties
        if (pd.required) {
          if (!(name in proto)) {
            throw new Error('Missing required property: '+name);
          }
        } else if (pd.conflict) { // check for remaining conflicting properties
          throw new Error('Remaining conflicting property: '+name);
        } else if ('value' in pd) { // data property
          // freeze all function properties and their prototype
          if (pd.method) { // the property is meant to be used as a method
            // bind 'this' in trait method to the composite object
            properties[name] = {
              value: freezeAndBind(pd.value, self),
              enumerable: pd.enumerable,
              configurable: pd.configurable,
              writable: pd.writable
            };
          } else {
            properties[name] = pd;
          }
        } else { // accessor property
          properties[name] = {
            get: pd.get ? freezeAndBind(pd.get, self) : undefined,
            set: pd.set ? freezeAndBind(pd.set, self) : undefined,
            enumerable: pd.enumerable,
            configurable: pd.configurable,
            writable: pd.writable            
          };
        }
      });
  
      defineProperties(self, properties);
      return freeze(self);
    }
  
    /** A shorthand for create(Object.prototype, trait({...}), options) */
    function object(record, options) {
      return create(Object.prototype, trait(record), options);
    }
  
    /**
     * Tests whether two traits are equivalent. T1 is equivalent to T2 iff
     * both describe the same set of property names and for all property
     * names n, T1[n] is equivalent to T2[n]. Two property descriptors are
     * equivalent if they have the same value, accessors and attributes.
     *
     * @return a boolean indicating whether the two argument traits are equivalent.
     */
    function eqv(trait1, trait2) {
      var names1 = getOwnPropertyNames(trait1);
      var names2 = getOwnPropertyNames(trait2);
      var name;
      if (names1.length !== names2.length) {
        return false;
      }
      for (var i = 0; i < names1.length; i++) {
        name = names1[i];
        if (!trait2[name] || !isSameDesc(trait1[name], trait2[name])) {
          return false;
        }
      }
      return true;
    }
    
    // if this code is ran in ES3 without an Object.create function, this
    // library will define it on Object:
    if (!Object.create) {
      Object.create = Object_create;
    }
    // ES5 does not by default provide Object.getOwnProperties
    // if it's not defined, the Traits library defines this utility function on Object
    if(!Object.getOwnProperties) {
      Object.getOwnProperties = getOwnProperties;
    }
    
    // expose the public API of this module
    function Trait(record) {
      // calling Trait as a function creates a new atomic trait
      return trait(record);
    }
    Trait.required = freeze(required);
    Trait.compose = freeze(compose);
    Trait.resolve = freeze(resolve);
    Trait.override = freeze(override);
    Trait.create = freeze(create);
    Trait.eqv = freeze(eqv);
    Trait.object = freeze(object); // not essential, cf. create + trait
    return freeze(Trait);
    
  })();
  
  if (typeof exports !== "undefined") { // CommonJS module support
    exports.Trait = Trait;
  }
  
  var Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  
    // public method for encoding
    encode : function (input) {
    var output = "";
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0;
  
      input = Base64._utf8_encode(input);
  
      while (i < input.length) {
  
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
  
        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;
  
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
  
        output = output +
        this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
        this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
  
      }
  
      return output;
    },
  
    // public method for decoding
    decode : function (input) {
      var output = "";
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
  
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  
      while (i < input.length) {
  
        enc1 = this._keyStr.indexOf(input.charAt(i++));
        enc2 = this._keyStr.indexOf(input.charAt(i++));
        enc3 = this._keyStr.indexOf(input.charAt(i++));
        enc4 = this._keyStr.indexOf(input.charAt(i++));
  
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
  
        output = output + String.fromCharCode(chr1);
  
        if (enc3 != 64) {
          output = output + String.fromCharCode(chr2);
        }
        if (enc4 != 64) {
          output = output + String.fromCharCode(chr3);
        }
  
      }
  
      if (i != input.length) {
    		  	//messages.addMessage(BASE64_BROKEN);
  	  		throw "error";
      }
  
      output = Base64._utf8_decode(output);
  
      return output;
  
    },
  
    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
      string = string.replace(/\r\n/g,"\n");
      var utftext = "";
  
      for (var n = 0; n < string.length; n++) {
  
        var c = string.charCodeAt(n);
  
        if (c < 128) {
          utftext += String.fromCharCode(c);
        }
        else if((c > 127) && (c < 2048)) {
          utftext += String.fromCharCode((c >> 6) | 192);
          utftext += String.fromCharCode((c & 63) | 128);
        }
        else {
          utftext += String.fromCharCode((c >> 12) | 224);
          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
          utftext += String.fromCharCode((c & 63) | 128);
        };
  
      };
  
      return utftext;
    },
  
    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
      var string = "";
      var i = 0;
      var c = c1 = c2 = 0;
  
      while ( i < utftext.length ) {
  
        c = utftext.charCodeAt(i);
  
        if (c < 128) {
          string += String.fromCharCode(c);
          i++;
        }
        else if((c > 191) && (c < 224)) {
          c2 = utftext.charCodeAt(i+1);
          string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
          i += 2;
        }
        else {
          c2 = utftext.charCodeAt(i+1);
          c3 = utftext.charCodeAt(i+2);
          string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
          i += 3;
        }
  
      }
  
      return string;
    }
  };
  
  var EventEmitter = function() {
  };
  
  EventEmitter.prototype.emit = function (type) {
    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events || !this._events.error ||
          (this._events.error instanceof Array && !this._events.error.length))
      {
        if (arguments[1] instanceof Error) {
          throw arguments[1];
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }
  
    if (!this._events) return false;
    if (!this._events[type]) return false;
  
    if (typeof this._events[type] == 'function') {
      if (arguments.length < 3) {
        // fast case
        this._events[type].call( this
                               , arguments[1]
                               , arguments[2]
                               );
      } else {
        // slower
        var args = Array.prototype.slice.call(arguments, 1);
        this._events[type].apply(this, args);
      }
      return true;
  
    } else if (this._events[type] instanceof Array) {
      var args = Array.prototype.slice.call(arguments, 1);
  
  
      var listeners = this._events[type].slice(0);
      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
      return true;
  
    } else {
      return false;
    }
  };
  
  EventEmitter.prototype.addListener = function (type, listener) {
    if ('function' !== typeof listener) {
      throw new Error('addListener only takes instances of Function');
    }
  
    if (!this._events) this._events = {};
  
    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit("newListener", type, listener);
  
    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    } else if (this._events[type] instanceof Array) {
      // If we've already got an array, just append.
      this._events[type].push(listener);
    } else {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }
  
    return this;
  };
  
  
  EventEmitter.prototype.removeListener = function (type, listener) {
    if ('function' !== typeof listener) {
      throw new Error('removeListener only takes instances of Function');
    }
  
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events || !this._events[type]) return this;
  
    var list = this._events[type];
  
    if (list instanceof Array) {
      var i = list.indexOf(listener);
      if (i < 0) return this;
      list.splice(i, 1);
    } else if (this._events[type] === listener) {
      this._events[type] = null;
    }
  
    return this;
  };
  
  EventEmitter.prototype.removeAllListeners = function (type) {
    // does not use listeners(), so no side effect of creating _events[type]
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
  };
  
  EventEmitter.prototype.listeners = function (type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!(this._events[type] instanceof Array)) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };


})(
  (function() {
    if (typeof exports !== "undefined") {
      return exports;
    } else if (typeof window !== "undefined") {
      window.COUCH = {};
      return window.COUCH;
    }
    
    throw new Error("Could not load module");
  }()));